Contents                                                                             xiii
         4 Recursion                                                                148
           4.1 Illustrative Examples . . . . . . . . . . . .    . . . . . . . . . . 150
                4.1.1 The Factorial Function . . . . . . . .    . . . . . . . . . . 150
                4.1.2 Drawing an English Ruler . . . . . . .    . . . . . . . . . . 152
                4.1.3 Binary Search . . . . . . . . . . . . .   . . . . . . . . . . 155
                4.1.4 File Systems . . . . . . . . . . . . . .  . . . . . . . . . . 157
           4.2 Analyzing Recursive Algorithms . . . . . .       . . . . . . . . . . 161
           4.3 Recursion Run Amok . . . . . . . . . . . .       . . . . . . . . . . 165
                4.3.1 Maximum Recursive Depth in Python         . . . . . . . . . . 168
           4.4 Further Examples of Recursion . . . . . . .      . . . . . . . . . . 169
                4.4.1 Linear Recursion . . . . . . . . . . . .  . . . . . . . . . . 169
                4.4.2 Binary Recursion . . . . . . . . . . .    . . . . . . . . . . 174
                4.4.3 Multiple Recursion . . . . . . . . . .    . . . . . . . . . . 175
           4.5 Designing Recursive Algorithms . . . . . .       . . . . . . . . . . 177
           4.6 Eliminating Tail Recursion . . . . . . . . .     . . . . . . . . . . 178
           4.7 Exercises . . . . . . . . . . . . . . . . . . .  . . . . . . . . . . 180
         5 Array-Based Sequences                                                    183
           5.1 Python’s Sequence Types . . . . . . . . . .      . . . . . . . . . . 184
           5.2 Low-Level Arrays . . . . . . . . . . . . . . .   . . . . . . . . . . 185
                5.2.1 Referential Arrays . . . . . . . . . . .  . . . . . . . . . . 187
                5.2.2 Compact Arrays in Python . . . . . .      . . . . . . . . . . 190
           5.3 Dynamic Arrays and Amortization . . . . .        . . . . . . . . . . 192
                5.3.1 Implementing a Dynamic Array . . . .      . . . . . . . . . . 195
                5.3.2 Amortized Analysis of Dynamic Arrays      . . . . . . . . . . 197
                5.3.3 Python’s List Class . . . . . . . . . .   . . . . . . . . . . 201
           5.4 Eﬃciency of Python’s Sequence Types . .          . . . . . . . . . . 202
                5.4.1 Python’s List and Tuple Classes . . .     . . . . . . . . . . 202
                5.4.2 Python’s String Class . . . . . . . . .   . . . . . . . . . . 208
           5.5 Using Array-Based Sequences . . . . . . .        . . . . . . . . . . 210
                5.5.1 Storing High Scores for a Game . . .      . . . . . . . . . . 210
                5.5.2 Sorting a Sequence . . . . . . . . . .    . . . . . . . . . . 214
                5.5.3 Simple Cryptography . . . . . . . . .     . . . . . . . . . . 216
           5.6 Multidimensional Data Sets . . . . . . . .       . . . . . . . . . . 219
           5.7 Exercises . . . . . . . . . . . . . . . . . . .  . . . . . . . . . . 224
         6 Stacks, Queues, and Deques                                               228
           6.1 Stacks . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 229
                6.1.1 The Stack Abstract Data Type . . . . . .      . . . . . . . . 230
                6.1.2 Simple Array-Based Stack Implementation       . . . . . . . . 231
                6.1.3 Reversing Data Using a Stack . . . . . .      . . . . . . . . 235
                6.1.4 Matching Parentheses and HTML Tags .          . . . . . . . . 236
