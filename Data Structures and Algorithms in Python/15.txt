xiv                                                                      Contents
      6.2 Queues . . . . . . . . . . . . . . . . . . . . . . .  . . . . . . . 239
           6.2.1 The Queue Abstract Data Type . . . . . .       . . . . . . . 240
           6.2.2 Array-Based Queue Implementation . . . .       . . . . . . . 241
      6.3 Double-Ended Queues . . . . . . . . . . . . . . .     . . . . . . . 247
           6.3.1 The Deque Abstract Data Type . . . . . .       . . . . . . . 247
           6.3.2 Implementing a Deque with a Circular Array     . . . . . . . 248
           6.3.3 Deques in the Python Collections Module .      . . . . . . . 249
      6.4 Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 250
    7 Linked Lists                                                            255
      7.1 Singly Linked Lists . . . . . . . . . . . . . . . . . . . . . . . . 256
           7.1.1 Implementing a Stack with a Singly Linked List . .     . . . 261
           7.1.2 Implementing a Queue with a Singly Linked List . .     . . . 264
      7.2 Circularly Linked Lists . . . . . . . . . . . . . . . . . . . . . . 266
           7.2.1 Round-Robin Schedulers . . . . . . . . . . . . . .     . . . 267
           7.2.2 Implementing a Queue with a Circularly Linked List     . . . 268
      7.3 Doubly Linked Lists . . . . . . . . . . . . . . . . . . . .   . . . 270
           7.3.1 Basic Implementation of a Doubly Linked List . . .     . . . 273
           7.3.2 Implementing a Deque with a Doubly Linked List .       . . . 275
      7.4 The Positional List ADT . . . . . . . . . . . . . . . . .     . . . 277
           7.4.1 The Positional List Abstract Data Type . . . . . .     . . . 279
           7.4.2 Doubly Linked List Implementation . . . . . . . . .    . . . 281
      7.5 Sorting a Positional List . . . . . . . . . . . . . . . . .   . . . 285
      7.6 Case Study: Maintaining Access Frequencies . . . . .          . . . 286
           7.6.1 Using a Sorted List . . . . . . . . . . . . . . . . .  . . . 286
           7.6.2 Using a List with the Move-to-Front Heuristic . . .    . . . 289
      7.7 Link-Based vs. Array-Based Sequences . . . . . . . . .        . . . 292
      7.8 Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 294
    8 Trees                                                                   299
      8.1 General Trees . . . . . . . . . . . . . . . . . . . . . . . . . . . 300
           8.1.1 Tree DeÔ¨Ånitions and Properties . . . . . . . .   . . . . . . 301
           8.1.2 The Tree Abstract Data Type . . . . . . . .      . . . . . . 305
           8.1.3 Computing Depth and Height . . . . . . . . .     . . . . . . 308
      8.2 Binary Trees . . . . . . . . . . . . . . . . . . . . .  . . . . . . 311
           8.2.1 The Binary Tree Abstract Data Type . . . . .     . . . . . . 313
           8.2.2 Properties of Binary Trees . . . . . . . . . .   . . . . . . 315
      8.3 Implementing Trees . . . . . . . . . . . . . . . . .    . . . . . . 317
           8.3.1 Linked Structure for Binary Trees . . . . . . .  . . . . . . 317
           8.3.2 Array-Based Representation of a Binary Tree      . . . . . . 325
           8.3.3 Linked Structure for General Trees . . . . . .   . . . . . . 327
      8.4 Tree Traversal Algorithms . . . . . . . . . . . . .     . . . . . . 328
